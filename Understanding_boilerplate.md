Part 1 of Documentation: Introduction and Project Setup

# Probaha Coaching Center Management System - Boilerplate Documentation

## 1. Introduction

### 1.1. Purpose of the Boilerplate
This document provides a comprehensive explanation of the boilerplate code for the "Probaha Coaching Center Management System." The boilerplate is designed to offer a robust, scalable, and maintainable foundation for developing the full application. It incorporates best practices for backend API development, frontend structure for admin panels, and modern development workflows. The primary goal is to accelerate development by providing a well-structured starting point with essential features and configurations already in place.

### 1.2. Core Technologies
The boilerplate leverages a stack of modern and widely-used technologies:
*   **Backend:**
    *   **Node.js:** A JavaScript runtime environment for executing server-side code.
    *   **Fastify:** A high-performance, low-overhead web framework for Node.js, used to build APIs.
    *   **TypeScript:** A superset of JavaScript that adds static typing, enhancing code quality and maintainability.
    *   **Sequelize:** A promise-based Node.js ORM (Object-Relational Mapper) for interacting with relational databases.
    *   **MySQL:** The chosen relational database management system for data persistence.
*   **Frontend (Admin Panels & Views):**
    *   **React:** A JavaScript library for building dynamic user interfaces, used for the admin panels.
    *   **Vite:** A modern frontend build tool providing fast development server and optimized production builds for React applications.
    *   **EJS (Embedded JavaScript templates):** A templating language used for server-side rendering of some simpler views.
*   **General Development & Tooling:**
    *   **Docker:** For containerization, ensuring consistent deployment environments.
    *   **ESLint & Prettier:** For code linting and formatting.
    *   **Jest:** A JavaScript testing framework.

---

## 2. Project Setup & Configuration

### 2.1. Key Files & Directories (Root Level)
*   **`package.json`:** Defines project metadata, lists dependencies (`dependencies` and `devDependencies`), and contains `scripts` for common tasks like starting the server, building assets, running tests, and linting.
*   **`.env.example`:** A template file for environment variables. Copy this to a `.env` file (which is gitignored) to store sensitive information like database credentials, API keys, and application-specific settings.
*   **`config/config.js` (Recommended for Sequelize CLI):** Configuration file for `sequelize-cli`, defining database connection parameters for different environments by sourcing values from `.env`.
*   **`.sequelizerc` (Recommended for Sequelize CLI):** Configuration file for `sequelize-cli` that specifies paths to `config/config.js`, migrations, and seeders.
*   **`tsconfig.json`:** Configures the TypeScript compiler (tsc) options for the backend codebase.
*   **`vite-config-admin.js`, `vite-config-super-admin.js`:** Configuration files for Vite, used to build the React-based admin frontend panels.
*   **`Dockerfile`:** Instructions for building a Docker image of the application, facilitating containerized deployments.
*   **`jest.config.js`:** Configuration for the Jest testing framework.
*   **`.eslintrc.json`, `.prettierrc`:** Configuration for ESLint (code linting) and Prettier (code formatting) to maintain code consistency and quality.
*   **`src/`:** Contains all backend TypeScript source code.
    *   Within `src/modules/your_module_name/models/`:
        *   `model.ts` (or `your_entity.model.ts`): Defines the main Sequelize model for the module.
        *   `model_relations.ts`: Defines relationships for the module's models.
        *   Note: Module-specific `db.ts`, `migrations/`, and `seeders/` subfolders within `src/modules/*/models/` are discouraged in favor of global configurations and paths.
*   **`public/`:** Contains static assets, server-rendered EJS views, and the source code for client-side React admin panels.
*   **`migrations/` (Root Level, Recommended):** Stores all database migration files, generated by `sequelize-cli`.
*   **`seeders/` (Root Level, Recommended):** Stores all database seeder files for populating initial data, generated by `sequelize-cli`.

### 2.2. Environment Variables
The application relies on environment variables for configuration, especially for sensitive data or settings that differ between environments (development, testing, production).
1.  Copy `.env.example` to a new file named `.env` in the project root.
2.  Update the values in `.env` with your specific settings:
    *   `DB_HOST`, `DB_USER`, `DB_PASS`, `DB_NAME`, `DB_PORT`: Database connection details. These are used by both the application at runtime and by `sequelize-cli` (via `config/config.js`).
    *   `APP_PORT`: Port on which the backend server will run.
    *   `NODE_ENV`: Set to `development`, `production`, or `test`. This also determines which configuration `sequelize-cli` uses from `config/config.js`.
    *   `JWT_SECRET`: Secret key for signing JSON Web Tokens.
    *   Other API keys or application-specific configurations.
*   The `dotenv` package is used to load these variables from `.env` into `process.env`. The `config/config.js` for Sequelize CLI should also use `dotenv` to load these variables.

### 2.3. Running the Application
Common scripts are defined in `package.json`:
*   **Development Server (Backend):**
    ```bash
    npm run server  # Uses nodemon for automatic restarts on file changes
    # OR
    npm run serve   # Uses ts-node to run directly
    ```
*   **Frontend Admin Panel Development (Vite):**
    These commands typically start Vite's development server with hot module replacement (HMR) and also build the assets. The boilerplate uses `--watch` which implies continuous building.
    ```bash
    npm run admin         # For the 'admin' panel
    npm run super_admin   # For the 'super_admin' panel
    ```
*   **Production Build (Frontend):**
    The same Vite commands (`npm run admin`, `npm run super_admin`) build the frontend assets for production. The `--sourcemap` flag might be included. A CI-specific script like `npm run super_admin:ci` is also present.
*   Consult `package.json` for the exact commands and their behavior.

### 2.4. Database Setup & Migrations
The application uses Sequelize for database interaction. Database schema changes are managed strictly through migrations using `sequelize-cli`. **It is critical to rely on migrations for all schema alterations and avoid using `sequelize.sync()` in the application code.**

1.  **Prerequisites:**
    *   Ensure your database credentials in `.env` are correct and populated.
    *   It's highly recommended to have a `config/config.js` file that `sequelize-cli` uses to connect to the database. This file should load credentials from `.env`. Example `config/config.js`:
        ```javascript
        // config/config.js
        require('dotenv').config({ path: '.env' }); // Ensure .env is loaded

        module.exports = {
          development: {
            username: process.env.DB_USER,
            password: process.env.DB_PASS,
            database: process.env.DB_DATABASE,
            host: process.env.DB_HOST,
            port: process.env.DB_PORT || 3306,
            dialect: 'mysql',
            migrationStorageTableName: 'sequelize_meta', // Optional: customize migration table name
            seederStorageTableName: 'sequelize_data'    // Optional: customize seeder table name
          },
          // Add similar configurations for 'test' and 'production' environments
        };
        ```
    *   Create a `.sequelizerc` file in the project root to specify paths for `sequelize-cli`:
        ```javascript
        // .sequelizerc
        const path = require('path');

        module.exports = {
          'config': path.resolve('config', 'config.js'),
          'models-path': path.resolve('src', 'database', 'models_placeholder'), // Note: Actual models are in src/modules
          'migrations-path': path.resolve('migrations'),
          'seeders-path': path.resolve('seeders')
        };
        ```
        The `models-path` here is primarily for `sequelize-cli` model generation commands; the application itself loads models from `src/modules`.

2.  **Creating Migrations:** When you change a model (e.g., add a table, add or modify a column), you need to create a migration file:
    ```bash
    npx sequelize-cli migration:generate --name <descriptive-name-of-migration>
    # Example: npx sequelize-cli migration:generate --name create-users-table
    # Example: npx sequelize-cli migration:generate --name add-bio-to-users-table
    ```
    This command creates a new migration file in the `migrations/` directory (as specified in `.sequelizerc`). Edit this file to define the `up` function (to apply the changes) and the `down` function (to revert the changes) using Sequelize's `QueryInterface`.

3.  **Running Migrations:** To apply all pending migrations to your database:
    ```bash
    npx sequelize-cli db:migrate
    ```
    This command will execute the `up` function of all migration files in the `migrations/` folder that have not yet been run. It determines the environment (development, production, etc.) from the `NODE_ENV` environment variable, or defaults to `development` if `NODE_ENV` is not set. You can specify an environment: `npx sequelize-cli db:migrate --env production`.

4.  **Rolling Back Migrations:**
    *   To revert the most recent migration:
        ```bash
        npx sequelize-cli db:migrate:undo
        ```
    *   To revert all migrations:
        ```bash
        npx sequelize-cli db:migrate:undo:all
        ```
    *   To revert to a specific migration:
        ```bash
        npx sequelize-cli db:migrate:undo --name <migration-file-name.js>
        ```

5.  **Seeders (Populating Data):** Seeders are used to populate the database with initial or test data.
    *   **Creating Seeders:**
        ```bash
        npx sequelize-cli seed:generate --name <descriptive-name-of-seeder>
        # Example: npx sequelize-cli seed:generate --name initial-user-roles
        ```
        This creates a new file in the `seeders/` directory (as specified in `.sequelizerc`). Edit this file to define the `up` (insert data) and `down` (remove data) functions.
    *   **Running Seeders:**
        ```bash
        npx sequelize-cli db:seed:all # Runs all seeders
        ```
    *   **Rolling Back Seeders:**
        ```bash
        npx sequelize-cli db:seed:undo # Unseeds the last run seeder
        npx sequelize-cli db:seed:undo:all # Unseeds all seeders
        npx sequelize-cli db:seed:undo --seed <seeder-file-name.js> # Unseeds a specific seeder
        ```

6.  **`migrate.sh` Script:**
    *   The existing `migrate.sh` script in the boilerplate appears to be focused on seeding data and may contain outdated references (like `--config src/configs/db.json` or specific module seeder paths if global paths are adopted).
    *   **Recommendation:** Review and update `migrate.sh`. If it's only for seeding, rename it (e.g., `seed.sh`). Ensure it uses the correct configuration path (`config/config.js` via `.sequelizerc` or by specifying `--config config/config.js`). If global seeder paths are adopted, the `--seeders-path` argument in the script might become redundant.
    *   Consider adding `npm` scripts to `package.json` for common database operations:
        ```json
        "scripts": {
          // ... other scripts
          "db:migrate": "npx sequelize-cli db:migrate",
          "db:migrate:undo": "npx sequelize-cli db:migrate:undo",
          "db:seed:all": "npx sequelize-cli db:seed:all",
          "db:seed:undo": "npx sequelize-cli db:seed:undo"
        }
        ```

**Important Note on `sequelize.sync()`:** Avoid using `sequelize.sync()` (especially `force: true` or `alter: true`) in your application's runtime code for schema management once you start using migrations. Migrations should be the single source of truth for your database schema. Using `sync()` can lead to inconsistencies between your models and the actual database structure defined by migrations, or unintended data loss.
---

Part 2 of Documentation: Backend Architecture (Sections 3.1 to 3.3)

## 3. Backend Architecture (`src/`)

The backend is the core of the application, handling business logic, API requests, and database interactions. It's built with Node.js, Fastify, and TypeScript, following a modular design pattern.

### 3.1. Overview
*   **Directory Structure of `src/`:**
    *   **`bootstrap/`:** Contains initialization code for the application.
        *   `app.ts`: Fastify server setup.
        *   `db.sql.ts`: Provides access to the global, singleton Sequelize database instance.
    *   **`common_types/`:** Holds shared TypeScript type definitions used across multiple modules.
    *   **`configs/`:** Application-level configuration files (e.g., `app.config.ts`).
    *   **`database/`:**
        *   `models.ts`: Handles the central registration of all Sequelize models and their relationships from various modules. It uses the global Sequelize instance from `bootstrap/db.sql.ts`.
        *   `models.type.ts`: Possibly shared database types (content not reviewed in this refactor).
    *   **`helpers/`:** Utility functions that provide common, reusable logic (e.g., error handling, response formatting).
    *   **`index.ts`:** The main entry point for the backend application. It initializes the database (via `src/database/models.ts` and `src/bootstrap/db.sql.ts`), sets up the Fastify server, registers models, and starts the server.
    *   **`modules/`:** The heart of the application's business logic, organized into feature-specific modules. Each module typically contains:
        *   `controller.ts`
        *   `routes.ts`
        *   `services/`
        *   `models/`:
            *   `model.ts` (or `your_entity.model.ts`): Defines the main Sequelize model.
            *   `model_relations.ts`: Defines relationships for the module's models.
            *   (Module-specific `db.ts` files are deprecated. Migrations and seeders are now global, not within module `models/` folders.)
        *   `api_test/` and `test/` for tests.
    *   **`plugins/`:** Custom Fastify plugins developed for the application.
    *   **`routes/`:** Global or root-level routes not specific to a module (e.g., `root.ts`).
    *   **`uploads/`:** (If used for direct server uploads) Directory for storing uploaded files.

### 3.2. Fastify Server Setup (`src/bootstrap/app.ts`)
The `FastifyApp` class is responsible for instantiating and configuring the Fastify server.
*   **Role of `FastifyApp`:**
    *   Initializes the Fastify instance (`Fastify({ logger: true })`).
    *   Orchestrates the registration of plugins, routes, middleware/hooks, and global handlers.
    *   Starts the HTTP server to listen for requests.
*   **Plugin Registration (`registerPlugins` method):**
    *   **Database Decoration:** Decorates the Fastify instance with the globally managed Sequelize models (e.g., `fastify.decorate('db', { models: Models.get() })`), making them accessible in routes and plugins via `request.server.db.models` or `this.db.models`. The actual Sequelize instance is managed by `src/bootstrap/db.sql.ts` and used by `src/database/models.ts`.
    *   **Core Fastify Plugins:** Registers and configures essential plugins like:
        *   `@fastify/cookie`: For HTTP cookie management.
        *   `@fastify/cors`: For Cross-Origin Resource Sharing configuration.
        *   `@fastify/multipart`: For handling `multipart/form-data` requests (file uploads), configured in `registerMultipartSupport`.
        *   `@fastify/static`: For serving static files from the `public/` directory.
        *   `@fastify/view`: For server-side template rendering (EJS).
        *   `@fastify/under-pressure`: For basic load shedding.
    *   **Custom Plugin Autoloading:** Uses `@fastify/autoload` to automatically load and register custom plugins from `src/plugins/`.
*   **Middleware and Hooks (`registerMiddlewares` method & `addHook`):**
    *   Fastify uses a hook system for executing code at specific points in the request lifecycle (e.g., `onRequest`, `preHandler`, `onResponse`).
    *   `FastifyApp` sets up global hooks, such as the one in the boilerplate for checking file extensions or logging request closure.
*   **Route Registration (`registerRoutes` method):**
    *   Uses a helper (`get_recursive_route_files_by_directory`) to find all `routes.ts` files within `src/modules/`.
    *   Registers each module's routes plugin with Fastify, applying a global prefix (e.g., `/api/v1`). This enables automatic discovery and activation of module-specific API endpoints.
*   **Global Error Handling (`setHandlers` method):**
    *   `setNotFoundHandler`: Defines a handler for requests that don't match any registered route, typically returning a 404 error.
    *   `setErrorHandler`: A crucial global error handler that catches any unhandled errors thrown during request processing. It logs the error and sends a standardized JSON response to the client, avoiding sensitive details in production.

### 3.3. Modular Design (`src/modules/`)
The backend is organized into modules, where each module represents a distinct feature or domain of the application (e.g., `user_management`, `blog_management`).
*   **Philosophy and Benefits:**
    *   **Separation of Concerns:** Isolates the logic for different features.
    *   **Maintainability:** Easier to understand, update, and debug smaller, focused codebases.
    *   **Scalability:** Simplifies adding new features without impacting existing ones significantly.
    *   **Team Collaboration:** Allows different developers or teams to work on different modules concurrently.
*   **Standard Module Structure (e.g., `src/modules/example_module/`):**
    *   **`routes.ts`:** Defines the API endpoints for the module.
    *   **`controller.ts`:** Contains functions that handle incoming HTTP requests.
    *   **`services/*.service.ts` (e.g., `example.service.ts`):** Houses the core business logic.
    *   **`models/`:**
        *   **`model.ts` (or `example.model.ts`):** Defines the primary Sequelize model for the module's main entity (e.g., `ExampleItem` model). This file should export the model name, table name, and the `init` function for the model. The naming convention for auto-discovery by `src/database/models.ts` is typically `model.ts`. If a different name is used (e.g., `example.model.ts`), the discovery mechanism in `src/database/models.ts` might need adjustment or the file might need to be explicitly imported there.
        *   **`model_relations.ts`:** Contains an `init()` function that defines relationships (associations like `belongsTo`, `hasMany`) for this module's models using `Models.get()` to access all registered models.
        *   (Note: `models/db.ts` is deprecated. Module-specific migrations and seeders are also deprecated in favor of global `migrations/` and `seeders/` folders.)
    *   **`models/model.validation.ts` (optional):** May contain specific validation schemas or functions.
    *   **`api_test/` & `test/`:** Directories for storing integration and unit tests.

---

Part 3 of Documentation: Backend Architecture (Sections 3.4 to 3.7)

### 3.4. Database Interaction with Sequelize
Sequelize is used as the Object-Relational Mapper (ORM) to interact with the MySQL database. The application uses a single, global Sequelize instance.
*   **Model Definition (`src/modules/*/models/model.ts` or `src/modules/*/models/[entity_name].model.ts`):**
    *   Each model file (e.g., `user.model.ts` defining `UserModel`) defines a class that extends `Sequelize.Model`.
    *   The static `init()` method defines the model's attributes, data types, constraints, etc. It receives the global Sequelize instance from `src/database/models.ts` during central registration.
    *   It's crucial that this `init()` function does *not* call `sequelize.sync()`. Schema is managed by migrations.
*   **Defining Relationships (`src/modules/*/models/model_relations.ts`):**
    *   Each module that needs to define or participate in relationships should have a `model_relations.ts` file.
    *   This file exports an `init()` function.
    *   Inside this `init()` function, you access all registered models via `Models.get()` (from `src/database/models.ts`) and define associations (e.g., `models.User.belongsTo(models.Role)`).
    *   The `src/database/models.ts` will call this `init()` function after all models have been individually initialized.
*   **Central Model Registration (`src/database/models.ts`):**
    *   The `Models` class in `src/database/models.ts` is responsible for the entire model lifecycle.
    *   **Initialization:** It discovers all `model.ts` (or similarly named, depending on its helper function `get_recursive_model_files_by_directory`) files within `src/modules/`. For each, it calls the exported `init(sequelizeInstance)` function, passing the single global Sequelize instance obtained from `src/bootstrap/db.sql.ts`.
    *   **Relationship Setup:** After all individual models are initialized, it discovers all `relations.ts` (or `model_relations.ts`) files within `src/modules/` and calls their exported `init()` functions to establish associations.
    *   **Access:** The registered and associated models are made available globally, typically via `fastify.db.models` (populated using `Models.get()`).
    *   **Important:** This central registration process should **not** call `sequelize.sync()`.
*   **Using Models in Services:**
    *   Services should access Sequelize models through the Fastify instance (e.g., `this.fastify.db.models.User`) or by importing them if a direct import pattern from a central model export is established.
    *   Standard Sequelize methods are used for CRUD, querying, eager/lazy loading, and transactions.
    *   Example: `const user = await this.fastify.db.models.UserModel.findByPk(id);`

### 3.5. Helpers & Custom Plugins
To promote code reusability and organization, the boilerplate utilizes helper functions and custom Fastify plugins.
*   **Purpose of `src/helpers/`:**
    *   Contains standalone utility functions that are not directly tied to the Fastify request lifecycle but provide common logic.
    *   Examples:
        *   `response.ts`: Standardizing API response structures (e.g., `successResponse`, `errorResponse`).
        *   `custom_error.ts`: Defining custom error classes (e.g., `NotFoundError`, `ValidationError`) that can carry specific status codes and details, aiding in centralized error handling.
        *   File system utilities (e.g., `get_recursive_route_files_by_directory.ts`) for autoloading mechanisms.
        *   Data formatting or transformation functions.
*   **Purpose of `src/plugins/`:**
    *   Extend the Fastify server instance with new functionalities, decorators, or hooks. Registered via `fastify.register()`.
    *   Examples:
        *   `sensible.ts`: Integrates `@fastify/sensible` for useful utilities like HTTP error constructors (`fastify.httpErrors`) and assertion helpers.
        *   Custom pagination plugins to standardize paginated API responses.
        *   Specialized file upload handlers building on `@fastify/multipart`.
        *   Enhanced logging plugins that add context or integrate with external services.
        *   Plugins to manage external API connections or other shared resources.

### 3.6. Error Handling Strategies
A multi-layered approach ensures errors are managed gracefully:
*   **Global Error Handler (`setErrorHandler` in `FastifyApp`):** The ultimate catch-all for unhandled errors. It logs the error and sends a standardized JSON response, hiding sensitive details in production. It can be customized to handle specific error types (e.g., `SequelizeValidationError`) differently.
*   **Custom Error Classes (`src/helpers/custom_error.ts`):** Allow throwing errors with specific HTTP status codes and additional details (e.g., `NotFoundError(404)`, `ValidationError(422)`). These are then interpreted by the global error handler.
*   **`try...catch` Blocks:** Used in services and controllers to handle anticipated errors locally, log them with context, or transform them into custom errors before they propagate.
*   **Input Validation:**
    *   **Fastify Route Schema Validation:** The preferred method. Defining JSON schemas for request `body`, `params`, and `query` in route definitions. Fastify automatically validates and returns a 400 error on failure.
    *   **Sequelize Model Validations:** Validations defined at the model attribute level (e.g., `allowNull: false`, `validate: { isEmail: true }`). These trigger `SequelizeValidationError` if rules are violated during database operations.
*   **Logging:** Comprehensive error logging (using Pino, Fastify's default logger) is essential for debugging. Logs should include context, stack traces, and relevant request information.
*   **Asynchronous Errors:** Proper handling of Promises (using `async/await` and `try/catch`) to ensure unhandled rejections don't crash the application.

### 3.7. Creating a New API Endpoint (Step-by-Step Guide)
Adding a new feature typically involves these steps:
1.  **Create Module Directory:** e.g., `src/modules/new_feature_management/`.
2.  **Define Model (`src/modules/new_feature_management/models/model.ts` or `.../new_feature.model.ts`):**
    *   Create the Sequelize model class, exporting its `init` function, `modelName`, and `tableName`.
    *   If it has relationships, prepare/update `src/modules/new_feature_management/models/model_relations.ts`.
3.  **Create Database Migration (in root `migrations/` folder):**
    *   Use `npx sequelize-cli migration:generate --name create-new_feature-table` (or a more descriptive name).
    *   Edit the generated migration file in the global `migrations/` directory to define the table schema (`up` function) and how to drop it (`down` function).
    *   Run `npx sequelize-cli db:migrate` (or `npm run db:migrate` if using package.json scripts).
4.  **Implement Service (`services/new_feature.service.ts`):**
    *   Create a service class.
    *   Write methods for business logic, using the new Sequelize model (e.g., `this.fastify.db.models.NewFeatureModel`).
5.  **Implement Controller (`controller.ts`):**
    *   Create a controller class.
    *   Write methods to handle HTTP requests, validate input, call service methods, and format responses.
6.  **Define Routes (`routes.ts`):**
    *   Create a Fastify plugin function.
    *   Define API routes and map them to controller methods.
7.  **Restart Server:** The application's autoloading mechanisms in `FastifyApp` (for routes) and `src/database/models.ts` (for models and relations) will automatically discover and integrate the new module's components.
8.  **Testing:** Write unit tests for services and integration tests for API endpoints.

---

Part 4 of Documentation: Frontend Overview, Development Workflow, and Conclusion

## 4. Frontend Overview (`public/`)

The `public/` directory serves all client-facing content, including static assets, server-rendered views, and the source code for more complex client-side applications like admin panels.

### 4.1. Static Assets
*   This includes images (e.g., `.png`, `.jpg`, `.svg`, `.ico`), global stylesheets (`.css`), client-side JavaScript files, fonts, and any other files that need to be served directly to the browser without server-side processing.
*   Fastify (via `@fastify/static` plugin, configured in `FastifyApp`) serves files from the `public/` directory, typically mapping the root of `public/` to the web server's root path (`/`).

### 4.2. Server-Side Views (`public/views/`)
*   **EJS Templates:** The boilerplate uses EJS (Embedded JavaScript templates) for server-side rendering of some HTML pages. These are typically simpler pages or initial shells for dashboards.
    *   Files have a `.ejs` extension (e.g., `public/views/auth/login.ejs`, `public/views/dashboard/admin.ejs`).
    *   EJS allows embedding JavaScript within HTML to dynamically generate content, iterate over data, and include partial templates.
*   **Usage with `@fastify/view`:**
    *   The `@fastify/view` plugin is configured in `FastifyApp` to use EJS as the templating engine and to look for templates in the `public/views/` directory.
    *   In route handlers (controllers), `reply.view('path/to/template.ejs', dataObject)` is used to render an EJS template and send the resulting HTML to the client. The `dataObject` makes data available within the template.

### 4.3. Client-Side Admin Panels (`public/management/`)
For more complex and interactive user interfaces, such as administrative dashboards, the boilerplate uses React.
*   **React (with TypeScript/TSX):**
    *   The source code for these React applications resides in subdirectories within `public/management/` (e.g., `public/management/super_admin/`, `public/management/admin/`).
    *   Components are typically written using TSX (TypeScript XML).
*   **Vite for Development and Build:**
    *   Vite is used as the build tool and development server for these React applications.
    *   Configuration files like `vite-config-admin.js` and `vite-config-super-admin.js` define how Vite processes and bundles the React code.
    *   **Development:** `npm run admin` or `npm run super_admin` (as defined in `package.json`) usually start Vite's dev server, providing features like Hot Module Replacement (HMR) for a fast development experience. These scripts often include `--watch` and `--sourcemap`.
    *   **Build:** The same commands also build the React applications into optimized static assets (HTML, JavaScript bundles, CSS files) that are then served by the Fastify backend (typically from a `dist` folder within each panel's directory, though this depends on Vite's configuration).
*   **Typical Structure (within each panel's directory, e.g., `public/management/super_admin/`):**
    *   `index.html`: The entry HTML file for the Single Page Application (SPA).
    *   `index.tsx` (or `main.tsx`): The main entry point for the React application, where the root component is rendered into the DOM.
    *   `components/` or `views/`: Directories for React components.
    *   `routes/`: Client-side routing configuration (e.g., using `react-router-dom`).
    *   `store/`: State management setup (e.g., Redux with `@reduxjs/toolkit`, Zustand, or React Context API).
    *   `assets/`: Panel-specific static assets.
    *   `helpers/`, `hooks/`, `services/` (for API calls): Utility functions, custom React hooks, and API interaction logic.

---

## 5. Development Workflow

The boilerplate is set up to support an efficient and modern development workflow.

### 5.1. Linting & Formatting
*   **ESLint (`.eslintrc.json`):** Used to analyze TypeScript/JavaScript code for potential errors, bugs, stylistic issues, and adherence to coding standards. Configuration is in `.eslintrc.json`.
    *   Scripts like `npm run server:lint` and `npm run client:lint` (from `package.json`) are typically used to run the linter, often with `--fix` to automatically correct issues.
*   **Prettier (`.prettierrc`):** An opinionated code formatter that ensures consistent code style across the project. Configuration is in `.prettierrc`.
    *   Often integrated with ESLint (`eslint-plugin-prettier`, `eslint-config-prettier`) and run via ESLint scripts or as a pre-commit hook.

### 5.2. Testing (`jest.config.js`)
*   **Jest:** The primary testing framework used for both backend and potentially frontend tests. Configuration is in `jest.config.js`. `ts-jest` is used to enable Jest to work with TypeScript code.
*   **Backend Tests:**
    *   **Unit Tests:** Located in `src/modules/*/test/`, these focus on testing individual functions or classes (e.g., service methods, helper functions) in isolation.
    *   **Integration Tests / API Tests:** Located in `src/modules/*/api_test/`, these test the interaction between different parts of the application, often by making actual HTTP requests to the API endpoints and verifying the responses, database state changes, etc. Tools like `supertest` might be used with Jest for this.
*   **Running Tests:**
    ```bash
    npm test # (Or a more specific script from package.json)
    ```
    Jest provides options for running tests in watch mode, generating coverage reports, etc.

### 5.3. Debugging
*   **Node.js Debugger:** Use the built-in Node.js inspector with a debugger client (like Chrome DevTools or VS Code debugger). Launch the server with the `--inspect` or `--inspect-brk` flag.
    ```bash
    node --inspect src/index.ts # (Or via nodemon configuration)
    ```
*   **Logging:** Effective logging (using Pino, Fastify's default, and custom loggers) is crucial. `pino-pretty` makes development logs more readable.
*   **TypeScript Type Safety:** TypeScript itself helps catch many potential errors during development before runtime.
*   **Browser Developer Tools:** For debugging frontend React applications.
*   **React Developer Tools:** Browser extension for inspecting React component hierarchies, props, and state.

---

## 6. Conclusion

### 6.1. Summary of Boilerplate Strengths
This boilerplate for the "Probaha Coaching Center Management System" provides a strong and comprehensive starting point by:
*   **Establishing a Modern Tech Stack:** Utilizing Node.js, Fastify, TypeScript, Sequelize, MySQL for the backend, and React with Vite for the frontend admin panels.
*   **Promoting a Modular Architecture:** The backend's organization into feature-specific modules (`src/modules/`) enhances maintainability, scalability, and team collaboration.
*   **Implementing Clear Design Patterns:** Following a structure similar to MVC with distinct layers for request handling (controllers), business logic (services), and data access (models).
*   **Automating Key Processes:** Leveraging autoloading for routes and models, and providing scripts for common development tasks (running, building, testing, linting).
*   **Prioritizing Code Quality:** Integrating TypeScript for static typing, ESLint for linting, and Prettier for code formatting.
*   **Including Robust Error Handling:** A multi-layered strategy ensures errors are caught, logged, and handled gracefully.
*   **Streamlining Database Management:** Using Sequelize ORM for database interactions and `sequelize-cli` for schema migrations.
*   **Supporting Efficient Frontend Development:** Using Vite for fast React development and optimized builds.

### 6.2. Next Steps for Development
With this boilerplate as a foundation, development can proceed by:
1.  **Defining Specific Features:** Flesh out the requirements for each module of the coaching center management system.
2.  **Developing Modules:** Implement each feature by creating or expanding modules within `src/modules/`, following the established patterns for models, services, controllers, and routes.
3.  **Building Frontend Interfaces:** Develop the React components and user interfaces for the admin panels and any other client-facing parts of the application.
4.  **Writing Comprehensive Tests:** Ensure high code coverage with unit and integration tests for both backend and frontend components.
5.  **Iterative Refinement:** Continuously review and refactor code to maintain quality and adapt to evolving requirements.
6.  **Security Considerations:** Implement authentication, authorization, input sanitization, and other security best practices throughout the application.
7.  **Deployment Planning:** Set up CI/CD pipelines and plan for deployment to staging and production environments, potentially using Docker.

This boilerplate aims to significantly reduce initial setup time and provide a clear path for building a complex and reliable application.

---

