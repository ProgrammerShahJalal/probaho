Part 1 of Documentation: Introduction and Project Setup

# Probaha Coaching Center Management System - Boilerplate Documentation

## 1. Introduction

### 1.1. Purpose of the Boilerplate
This document provides a comprehensive explanation of the boilerplate code for the "Probaha Coaching Center Management System." The boilerplate is designed to offer a robust, scalable, and maintainable foundation for developing the full application. It incorporates best practices for backend API development, frontend structure for admin panels, and modern development workflows. The primary goal is to accelerate development by providing a well-structured starting point with essential features and configurations already in place.

### 1.2. Core Technologies
The boilerplate leverages a stack of modern and widely-used technologies:
*   **Backend:**
    *   **Node.js:** A JavaScript runtime environment for executing server-side code.
    *   **Fastify:** A high-performance, low-overhead web framework for Node.js, used to build APIs.
    *   **TypeScript:** A superset of JavaScript that adds static typing, enhancing code quality and maintainability.
    *   **Sequelize:** A promise-based Node.js ORM (Object-Relational Mapper) for interacting with relational databases.
    *   **MySQL:** The chosen relational database management system for data persistence.
*   **Frontend (Admin Panels & Views):**
    *   **React:** A JavaScript library for building dynamic user interfaces, used for the admin panels.
    *   **Vite:** A modern frontend build tool providing fast development server and optimized production builds for React applications.
    *   **EJS (Embedded JavaScript templates):** A templating language used for server-side rendering of some simpler views.
*   **General Development & Tooling:**
    *   **Docker:** For containerization, ensuring consistent deployment environments.
    *   **ESLint & Prettier:** For code linting and formatting.
    *   **Jest:** A JavaScript testing framework.

---

## 2. Project Setup & Configuration

### 2.1. Key Files & Directories (Root Level)
*   **`package.json`:** Defines project metadata, lists dependencies (`dependencies` and `devDependencies`), and contains `scripts` for common tasks like starting the server, building assets, running tests, and linting.
*   **`.env.example`:** A template file for environment variables. Copy this to a `.env` file (which is gitignored) to store sensitive information like database credentials, API keys, and application-specific settings.
*   **`tsconfig.json`:** Configures the TypeScript compiler (tsc) options for the backend codebase.
*   **`vite-config-admin.js`, `vite-config-super-admin.js`:** Configuration files for Vite, used to build the React-based admin frontend panels.
*   **`Dockerfile`:** Instructions for building a Docker image of the application, facilitating containerized deployments.
*   **`jest.config.js`:** Configuration for the Jest testing framework.
*   **`.eslintrc.json`, `.prettierrc`:** Configuration for ESLint (code linting) and Prettier (code formatting) to maintain code consistency and quality.
*   **`src/`:** Contains all backend TypeScript source code.
*   **`public/`:** Contains static assets, server-rendered EJS views, and the source code for client-side React admin panels.
*   **`migrations/` (typically generated by `sequelize-cli`):** Stores database migration files.
*   **`seeders/` (typically generated by `sequelize-cli`):** Stores database seeder files for populating initial data.

### 2.2. Environment Variables
The application relies on environment variables for configuration, especially for sensitive data or settings that differ between environments (development, testing, production).
1.  Copy `.env.example` to a new file named `.env` in the project root.
2.  Update the values in `.env` with your specific settings:
    *   `DB_HOST`, `DB_USER`, `DB_PASS`, `DB_NAME`, `DB_PORT`: Database connection details.
    *   `APP_PORT`: Port on which the backend server will run.
    *   `NODE_ENV`: Set to `development`, `production`, or `test`.
    *   `JWT_SECRET`: Secret key for signing JSON Web Tokens.
    *   Other API keys or application-specific configurations.
*   The `dotenv` package is used to load these variables from `.env` into `process.env`.

### 2.3. Running the Application
Common scripts are defined in `package.json`:
*   **Development Server (Backend):**
    ```bash
    npm run server  # Uses nodemon for automatic restarts on file changes
    # OR
    npm run serve   # Uses ts-node to run directly
    ```
*   **Frontend Admin Panel Development (Vite):**
    These commands typically start Vite's development server with hot module replacement (HMR) and also build the assets. The boilerplate uses `--watch` which implies continuous building.
    ```bash
    npm run admin         # For the 'admin' panel
    npm run super_admin   # For the 'super_admin' panel
    ```
*   **Production Build (Frontend):**
    The same Vite commands (`npm run admin`, `npm run super_admin`) build the frontend assets for production. The `--sourcemap` flag might be included. A CI-specific script like `npm run super_admin:ci` is also present.
*   Consult `package.json` for the exact commands and their behavior.

### 2.4. Database Setup & Migrations
The application uses Sequelize for database interaction and `sequelize-cli` for managing database schema migrations.
1.  **Configuration:** Ensure your database credentials in `.env` are correct. Sequelize CLI might also use a configuration file (e.g., `config/config.json` if not customized, or it might be configured to use environment variables directly via `src/configs/database.config.js` if such a file exists and is referenced by `.sequelizerc`).
2.  **Creating Migrations:** When you change a model (add a table, add a column, modify a type), you need to create a migration:
    ```bash
    npx sequelize-cli migration:generate --name <descriptive-name-of-migration>
    # Example: npx sequelize-cli migration:generate --name create-users-table
    ```
    This creates a new file in the `migrations/` directory. Edit this file to define the `up` (apply changes) and `down` (revert changes) functions using Sequelize's `QueryInterface`.
3.  **Running Migrations:** To apply pending migrations to your database:
    ```bash
    npx sequelize-cli db:migrate
    # The project might have a script like ./migrate.sh which could encapsulate this.
    ```
4.  **Rolling Back Migrations:**
    ```bash
    npx sequelize-cli db:migrate:undo # Reverts the last applied migration
    npx sequelize-cli db:migrate:undo:all # Reverts all migrations
    ```
5.  **Seeders (Optional):** To populate the database with initial or test data:
    ```bash
    npx sequelize-cli seed:generate --name <descriptive-name-of-seeder>
    # Edit the seeder file in seeders/
    npx sequelize-cli db:seed:all # Runs all seeders
    npx sequelize-cli db:seed:undo # Unseeds the last run seeder
    ```
---

Part 2 of Documentation: Backend Architecture (Sections 3.1 to 3.3)

## 3. Backend Architecture (`src/`)

The backend is the core of the application, handling business logic, API requests, and database interactions. It's built with Node.js, Fastify, and TypeScript, following a modular design pattern.

### 3.1. Overview
*   **Directory Structure of `src/`:**
    *   **`bootstrap/`:** Contains initialization code for the application, primarily `app.ts` (Fastify server setup) and `db.sql.ts` (database connection setup - presumed).
    *   **`common_types/`:** Holds shared TypeScript type definitions used across multiple modules.
    *   **`configs/`:** Application-level configuration files (e.g., `app.config.ts`).
    *   **`database/`:** Code related to database model registration (`models.ts`) and possibly shared database types (`models.type.ts`).
    *   **`helpers/`:** Utility functions that provide common, reusable logic (e.g., error handling, response formatting).
    *   **`index.ts`:** The main entry point for the backend application. It initializes the database, sets up the Fastify server via `FastifyApp`, registers models, and starts the server.
    *   **`modules/`:** The heart of the application's business logic, organized into feature-specific modules.
    *   **`plugins/`:** Custom Fastify plugins developed for the application.
    *   **`routes/`:** Global or root-level routes not specific to a module (e.g., `root.ts`).
    *   **`uploads/`:** (If used for direct server uploads) Directory for storing uploaded files.

### 3.2. Fastify Server Setup (`src/bootstrap/app.ts`)
The `FastifyApp` class is responsible for instantiating and configuring the Fastify server.
*   **Role of `FastifyApp`:**
    *   Initializes the Fastify instance (`Fastify({ logger: true })`).
    *   Orchestrates the registration of plugins, routes, middleware/hooks, and global handlers.
    *   Starts the HTTP server to listen for requests.
*   **Plugin Registration (`registerPlugins` method):**
    *   **Database Decoration:** Decorates the Fastify instance with the Sequelize instance (`fastify.decorate('db', sequelizeInstance)`), making it accessible in routes and plugins via `request.server.db` or `this.db`.
    *   **Core Fastify Plugins:** Registers and configures essential plugins like:
        *   `@fastify/cookie`: For HTTP cookie management.
        *   `@fastify/cors`: For Cross-Origin Resource Sharing configuration.
        *   `@fastify/multipart`: For handling `multipart/form-data` requests (file uploads), configured in `registerMultipartSupport`.
        *   `@fastify/static`: For serving static files from the `public/` directory.
        *   `@fastify/view`: For server-side template rendering (EJS).
        *   `@fastify/under-pressure`: For basic load shedding.
    *   **Custom Plugin Autoloading:** Uses `@fastify/autoload` to automatically load and register custom plugins from `src/plugins/`.
*   **Middleware and Hooks (`registerMiddlewares` method & `addHook`):**
    *   Fastify uses a hook system for executing code at specific points in the request lifecycle (e.g., `onRequest`, `preHandler`, `onResponse`).
    *   `FastifyApp` sets up global hooks, such as the one in the boilerplate for checking file extensions or logging request closure.
*   **Route Registration (`registerRoutes` method):**
    *   Uses a helper (`get_recursive_route_files_by_directory`) to find all `routes.ts` files within `src/modules/`.
    *   Registers each module's routes plugin with Fastify, applying a global prefix (e.g., `/api/v1`). This enables automatic discovery and activation of module-specific API endpoints.
*   **Global Error Handling (`setHandlers` method):**
    *   `setNotFoundHandler`: Defines a handler for requests that don't match any registered route, typically returning a 404 error.
    *   `setErrorHandler`: A crucial global error handler that catches any unhandled errors thrown during request processing. It logs the error and sends a standardized JSON response to the client, avoiding sensitive details in production.

### 3.3. Modular Design (`src/modules/`)
The backend is organized into modules, where each module represents a distinct feature or domain of the application (e.g., `user_management`, `blog_management`).
*   **Philosophy and Benefits:**
    *   **Separation of Concerns:** Isolates the logic for different features.
    *   **Maintainability:** Easier to understand, update, and debug smaller, focused codebases.
    *   **Scalability:** Simplifies adding new features without impacting existing ones significantly.
    *   **Team Collaboration:** Allows different developers or teams to work on different modules concurrently.
*   **Standard Module Structure (e.g., `src/modules/example_module/`):**
    *   **`routes.ts`:** Defines the API endpoints for the module (e.g., `GET /api/v1/example_module/items`). It maps these HTTP routes to specific controller functions.
    *   **`controller.ts`:** Contains functions that handle incoming HTTP requests. Responsibilities include:
        *   Validating request parameters, query strings, and body payload (often using Fastify's schema validation or helper validation functions).
        *   Calling appropriate methods in the module's service(s) to perform business logic.
        *   Formatting the response (success or error) and sending it back to the client using the `reply` object.
    *   **`services/*.service.ts` (e.g., `example.service.ts`):** Houses the core business logic for the module. Services:
        *   Are called by controllers.
        *   Interact with database models (Sequelize) to perform CRUD (Create, Read, Update, Delete) operations.
        *   May call other services or utility helpers.
        *   Encapsulate data transformations or complex operations.
    *   **`models/model.ts`:** Defines the primary Sequelize model for the module's main entity (e.g., `ExampleItem` model corresponding to an `example_items` table). Includes attribute definitions, data types, validations, and instance/static methods.
    *   **`models/model_relations.ts` (or within `model.ts`'s `associate` method):** Defines relationships (associations like `belongsTo`, `hasMany`, `belongsToMany`) between this module's model(s) and other models in the application.
    *   **`models/model.validation.ts` (optional):** May contain specific validation schemas or functions for the module's data structures, used by controllers or services if not solely relying on Fastify's route schemas or Sequelize model validations.
    *   **`api_test/` & `test/`:** Directories for storing integration tests (testing API endpoints) and unit tests (testing individual services, helpers, etc.) for the module, typically using Jest.

---

Part 3 of Documentation: Backend Architecture (Sections 3.4 to 3.7)

### 3.4. Database Interaction with Sequelize
Sequelize is used as the Object-Relational Mapper (ORM) to interact with the MySQL database, abstracting raw SQL queries into JavaScript objects and methods.
*   **Model Definition (`src/modules/*/models/model.ts`):**
    *   Each model file defines a class that extends `Sequelize.Model`.
    *   The static `init()` method defines the model's attributes (table columns), their data types (`DataTypes.STRING`, `DataTypes.INTEGER`, etc.), constraints (primary key, allowNull, unique), default values, and model-level validations.
    *   Options passed to `init()` include the Sequelize instance, `modelName`, `tableName`, `timestamps` (for `created_at`, `updated_at`), and `underscored` (for snake_case column names).
    *   Instance methods can be added to model classes for record-specific logic, and static methods for table-level operations.
*   **Defining Relationships (`associate` method in model):**
    *   Relationships between models are defined in a static `associate(models)` method within each model class. This method receives an object containing all registered models.
    *   Common association types:
        *   `belongsTo`: For one-to-one or one-to-many relationships (foreign key on the source model).
        *   `hasMany`: For one-to-many relationships (foreign key on the target model).
        *   `belongsToMany`: For many-to-many relationships, requiring a `through` option to specify the junction table/model.
    *   Options for associations include `foreignKey`, `as` (alias for the relationship, used in queries and generated methods), `onDelete`, and `onUpdate`.
*   **Central Model Registration (`src/database/models.ts`):**
    *   The `ModelsRegistry` class (or `Models` in the boilerplate) is responsible for discovering all `model.ts` files within `src/modules/`.
    *   It calls the `init()` function from each model file to define and initialize the model with the global Sequelize instance.
    *   After all models are initialized, it calls the static `associate()` method on each model, allowing relationships to be established across the entire application.
    *   The registered models are typically made accessible globally, often via `fastify.db.models`.
*   **Using Models in Services:**
    *   Services use the registered Sequelize models to perform database operations:
        *   **CRUD:** `Model.create()`, `Model.findByPk()`, `Model.findAll()`, `Model.findOne()`, `instance.update()`, `instance.destroy()`.
        *   **Querying:** Using `where` clauses for filtering, `order` for sorting, `limit` and `offset` for pagination, `attributes` for selecting specific columns.
        *   **Eager Loading:** Using the `include` option in query methods to fetch associated data in a single query (e.g., `Product.findAll({ include: [{ model: User, as: 'seller' }] })`).
        *   **Lazy Loading:** Accessing associated data through methods generated by Sequelize on model instances (e.g., `product.getSeller()`), which triggers separate database queries.
        *   **Transactions:** Sequelize supports database transactions for operations that need to be atomic (`sequelize.transaction(async (t) => { ... })`).

### 3.5. Helpers & Custom Plugins
To promote code reusability and organization, the boilerplate utilizes helper functions and custom Fastify plugins.
*   **Purpose of `src/helpers/`:**
    *   Contains standalone utility functions that are not directly tied to the Fastify request lifecycle but provide common logic.
    *   Examples:
        *   `response.ts`: Standardizing API response structures (e.g., `successResponse`, `errorResponse`).
        *   `custom_error.ts`: Defining custom error classes (e.g., `NotFoundError`, `ValidationError`) that can carry specific status codes and details, aiding in centralized error handling.
        *   File system utilities (e.g., `get_recursive_route_files_by_directory.ts`) for autoloading mechanisms.
        *   Data formatting or transformation functions.
*   **Purpose of `src/plugins/`:**
    *   Extend the Fastify server instance with new functionalities, decorators, or hooks. Registered via `fastify.register()`.
    *   Examples:
        *   `sensible.ts`: Integrates `@fastify/sensible` for useful utilities like HTTP error constructors (`fastify.httpErrors`) and assertion helpers.
        *   Custom pagination plugins to standardize paginated API responses.
        *   Specialized file upload handlers building on `@fastify/multipart`.
        *   Enhanced logging plugins that add context or integrate with external services.
        *   Plugins to manage external API connections or other shared resources.

### 3.6. Error Handling Strategies
A multi-layered approach ensures errors are managed gracefully:
*   **Global Error Handler (`setErrorHandler` in `FastifyApp`):** The ultimate catch-all for unhandled errors. It logs the error and sends a standardized JSON response, hiding sensitive details in production. It can be customized to handle specific error types (e.g., `SequelizeValidationError`) differently.
*   **Custom Error Classes (`src/helpers/custom_error.ts`):** Allow throwing errors with specific HTTP status codes and additional details (e.g., `NotFoundError(404)`, `ValidationError(422)`). These are then interpreted by the global error handler.
*   **`try...catch` Blocks:** Used in services and controllers to handle anticipated errors locally, log them with context, or transform them into custom errors before they propagate.
*   **Input Validation:**
    *   **Fastify Route Schema Validation:** The preferred method. Defining JSON schemas for request `body`, `params`, and `query` in route definitions. Fastify automatically validates and returns a 400 error on failure.
    *   **Sequelize Model Validations:** Validations defined at the model attribute level (e.g., `allowNull: false`, `validate: { isEmail: true }`). These trigger `SequelizeValidationError` if rules are violated during database operations.
*   **Logging:** Comprehensive error logging (using Pino, Fastify's default logger) is essential for debugging. Logs should include context, stack traces, and relevant request information.
*   **Asynchronous Errors:** Proper handling of Promises (using `async/await` and `try/catch`) to ensure unhandled rejections don't crash the application.

### 3.7. Creating a New API Endpoint (Step-by-Step Guide)

This guide details the process of adding a new set of API endpoints for managing a hypothetical "Courses" feature.

**1. Plan Your API**
*   **Entity:** Course
*   **Attributes:** `id` (INT, PK, AI), `title` (VARCHAR), `description` (TEXT), `start_date` (DATE), `end_date` (DATE), `is_published` (BOOLEAN, default: false), `created_at`, `updated_at`.
*   **Endpoints:**
    *   `POST /api/v1/courses`: Create a new course.
    *   `GET /api/v1/courses`: Get a list of all courses (with pagination/filtering).
    *   `GET /api/v1/courses/:id`: Get a single course by its ID.
    *   `PUT /api/v1/courses/:id`: Update an existing course.
    *   `DELETE /api/v1/courses/:id`: Delete a course.

**2. Create Module Directory**
Create the directory structure:
src/ └── modules/ └── course_management/ ├── models/ │ ├── model.ts │ └── model_relations.ts (if needed later) ├── services/ │ └── course.service.ts ├── controller.ts └── routes.ts


**3. Define the Sequelize Model (`src/modules/course_management/models/model.ts`)**
```typescript
// src/modules/course_management/models/model.ts
import { DataTypes, Model, Sequelize, CreationOptional, InferAttributes, InferCreationAttributes } from '@sequelize/core';
import type { Models } from '../../../database/models.type';

export interface CourseAttributes {
    id: CreationOptional<number>;
    title: string;
    description: string | null;
    start_date: Date;
    end_date: Date;
    is_published: CreationOptional<boolean>;
    created_at?: Date;
    updated_at?: Date;
}

export interface CourseCreationAttributes extends InferCreationAttributes<Course, { omit: 'id' | 'created_at' | 'updated_at' | 'is_published' }> {}

export class Course extends Model<InferAttributes<Course>, CourseCreationAttributes> implements CourseAttributes {
    declare id: CreationOptional<number>;
    declare title: string;
    declare description: string | null;
    declare start_date: Date;
    declare end_date: Date;
    declare is_published: boolean;
    declare readonly created_at: Date;
    declare readonly updated_at: Date;

    public static associate(models: Models) {
        // Example: Course.belongsTo(models.Teacher, { as: 'instructor', foreignKey: 'teacherId' });
    }
}

export const init = (sequelize: Sequelize): typeof Course => {
    Course.init(
        {
            id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },
            title: { type: DataTypes.STRING(255), allowNull: false },
            description: { type: DataTypes.TEXT, allowNull: true },
            start_date: { type: DataTypes.DATE, allowNull: false },
            end_date: { type: DataTypes.DATE, allowNull: false },
            is_published: { type: DataTypes.BOOLEAN, allowNull: false, defaultValue: false },
        },
        { sequelize, modelName: 'Course', tableName: 'courses', timestamps: true, underscored: true }
    );
    return Course;
};
export default init;
4. Create Database Migration

Run: npx sequelize-cli migration:generate --name create-courses-table
Edit the generated migration file (e.g., migrations/YYYYMMDDHHMMSS-create-courses-table.js):
'use strict';
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('courses', {
      id: { allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER },
      title: { type: Sequelize.STRING, allowNull: false },
      description: { type: Sequelize.TEXT },
      start_date: { type: Sequelize.DATE, allowNull: false },
      end_date: { type: Sequelize.DATE, allowNull: false },
      is_published: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: false },
      created_at: { allowNull: false, type: Sequelize.DATE },
      updated_at: { allowNull: false, type: Sequelize.DATE }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('courses');
  }
};
Run: npx sequelize-cli db:migrate (or your project's migration script).
5. Implement Service (src/modules/course_management/services/course.service.ts)

// src/modules/course_management/services/course.service.ts
import { FastifyInstance } from 'fastify';
import { Course, CourseCreationAttributes } from '../models/model';
import { CustomError, NotFoundError } from '../../../helpers/custom_error'; // Assuming these exist

export class CourseService {
    private server: FastifyInstance;

    constructor(server: FastifyInstance) {
        this.server = server;
    }

    async create(data: CourseCreationAttributes): Promise<Course> {
        try {
            const course = await this.server.db.models.Course.create(data);
            return course as Course;
        } catch (error: any) {
            this.server.log.error('CourseService.create error:', error);
            throw new CustomError(error.message || 'Failed to create course', 500);
        }
    }

    async findAll(query: any = {}): Promise<{ rows: Course[]; count: number }> {
        // Basic pagination example
        const limit = parseInt(query.limit) || 10;
        const page = parseInt(query.page) || 1;
        const offset = (page - 1) * limit;
        try {
            const { rows, count } = await this.server.db.models.Course.findAndCountAll({ limit, offset, order: [['created_at', 'DESC']] });
            return { rows: rows as Course[], count };
        } catch (error: any) {
            this.server.log.error('CourseService.findAll error:', error);
            throw new CustomError(error.message || 'Failed to retrieve courses', 500);
        }
    }

    async findById(id: number): Promise<Course> {
        const course = await this.server.db.models.Course.findByPk(id);
        if (!course) {
            throw new NotFoundError(`Course with ID ${id} not found`);
        }
        return course as Course;
    }

    async update(id: number, data: Partial<CourseCreationAttributes>): Promise<Course> {
        const course = await this.findById(id); // Leverages not found error
        try {
            await course.update(data);
            return course;
        } catch (error: any) {
            this.server.log.error(`CourseService.update error for ID ${id}:`, error);
            throw new CustomError(error.message || 'Failed to update course', 500);
        }
    }

    async delete(id: number): Promise<void> {
        const course = await this.findById(id); // Leverages not found error
        try {
            await course.destroy();
        } catch (error: any) {
            this.server.log.error(`CourseService.delete error for ID ${id}:`, error);
            throw new CustomError(error.message || 'Failed to delete course', 500);
        }
    }
}
6. Implement Controller (src/modules/course_management/controller.ts)

// src/modules/course_management/controller.ts
import { FastifyRequest, FastifyReply, FastifyInstance } from 'fastify';
import { CourseService } from './services/course.service';
import { CourseCreationAttributes } from './models/model';
import { successResponse } from '../../../helpers/response'; // Assuming a response helper

export class CourseController {
    private courseService: CourseService;
    private server: FastifyInstance;

    constructor(server: FastifyInstance) {
        this.server = server;
        this.courseService = new CourseService(server);
    }

    public create = async (request: FastifyRequest<{ Body: CourseCreationAttributes }>, reply: FastifyReply) => {
        // Validation is ideally handled by Fastify route schema
        const course = await this.courseService.create(request.body);
        return reply.code(201).send(successResponse(course, 'Course created successfully'));
    }

    public getAll = async (request: FastifyRequest<{ Querystring: { page?: string, limit?: string } }>, reply: FastifyReply) => {
        const { rows, count } = await this.courseService.findAll(request.query);
        const page = parseInt(request.query.page || '1');
        const limit = parseInt(request.query.limit || '10');
        return reply.send(successResponse(rows, 'Courses retrieved', { total: count, page, limit, totalPages: Math.ceil(count / limit) }));
    }

    public getById = async (request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) => {
        const course = await this.courseService.findById(parseInt(request.params.id));
        return reply.send(successResponse(course, 'Course retrieved'));
    }

    public update = async (request: FastifyRequest<{ Params: { id: string }, Body: Partial<CourseCreationAttributes> }>, reply: FastifyReply) => {
        const course = await this.courseService.update(parseInt(request.params.id), request.body);
        return reply.send(successResponse(course, 'Course updated successfully'));
    }

    public delete = async (request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) => {
        await this.courseService.delete(parseInt(request.params.id));
        return reply.code(204).send(); // Or successResponse(null, 'Course deleted') with 200
    }
}
7. Define Routes (src/modules/course_management/routes.ts)

// src/modules/course_management/routes.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { CourseController } from './controller';
import { CourseCreationAttributes } from './models/model'; // For schema typing

// Define JSON Schemas for validation and serialization (example for create)
const createCourseSchema = {
    body: {
        type: 'object',
        required: ['title', 'start_date', 'end_date'],
        properties: {
            title: { type: 'string', minLength: 3, maxLength: 255 },
            description: { type: 'string', nullable: true },
            start_date: { type: 'string', format: 'date' }, // Or 'date-time'
            end_date: { type: 'string', format: 'date' },
            is_published: { type: 'boolean', nullable: true }
        },
    },
    response: {
        201: { /* Define your success response schema here */ }
    }
};
// Define other schemas for update, getById, getAll (especially for querystring pagination)

export default async function courseRoutes(server: FastifyInstance, options: FastifyPluginOptions) {
    const courseController = new CourseController(server);

    server.post('/courses', { schema: createCourseSchema }, courseController.create);
    server.get('/courses', { /* schema: getAllCoursesSchema */ }, courseController.getAll);
    server.get('/courses/:id', { /* schema: getCourseByIdSchema */ }, courseController.getById);
    server.put('/courses/:id', { /* schema: updateCourseSchema */ }, courseController.update);
    server.delete('/courses/:id', { /* schema: deleteCourseSchema */ }, courseController.delete);
}
Route Schemas: Using Fastify's schema capabilities for request validation (body, params, querystring) and response serialization is highly recommended. This offloads validation from the controller and provides clear API contracts.
8. Restart Server & Test

Restart your development server (npm run server). The new module and its routes should be automatically loaded.
Test your new endpoints using a tool like Postman, Insomnia, or by writing integration tests (e.g., using Jest and Supertest).
POST /api/v1/courses with a JSON body.
GET /api/v1/courses.
GET /api/v1/courses/:id (use an ID from a created course).
PUT /api/v1/courses/:id with a JSON body.
DELETE /api/v1/courses/:id.
This detailed process ensures all layers of the backend (model, service, controller, routes) are correctly implemented for the new feature, along with necessary database changes and the benefits of schema validation.

3.8. Frontend Consumption of API Endpoints
Once backend API endpoints are created, the frontend (e.g., a React admin panel in public/management/) can interact with them to create, read, update, or delete data. This typically involves making HTTP requests.

1. API Service Layer (Frontend) It's good practice to create a dedicated service layer or API utility functions in the frontend to encapsulate API calls. This keeps components cleaner and centralizes API logic.

// Example: src/public/management/super_admin/services/api.ts or courseApi.ts
import axios from 'axios';

const API_BASE_URL = '/api/v1'; // Assuming Fastify serves API under this prefix

const apiClient = axios.create({
    baseURL: API_BASE_URL,
    headers: {
        'Content-Type': 'application/json',
        // Authorization: `Bearer ${getToken()}` // If auth is needed
    },
});

// Interceptors can be added for global error handling or request/response transformation
// apiClient.interceptors.response.use(...)

// Example for Courses API
export const courseApiService = {
    createCourse: async (courseData: any) => { // Replace 'any' with CourseCreationAttributes from backend if shared
        const response = await apiClient.post('/courses', courseData);
        return response.data; // Assuming backend sends { success: true, data: ..., message: ... }
    },
    getCourses: async (params: { page?: number; limit?: number } = {}) => {
        const response = await apiClient.get('/courses', { params });
        return response.data; // Expects paginated response
    },
    getCourseById: async (id: number) => {
        const response = await apiClient.get(`/courses/${id}`);
        return response.data;
    },
    updateCourse: async (id: number, courseData: any) => {
        const response = await apiClient.put(`/courses/${id}`, courseData);
        return response.data;
    },
    deleteCourse: async (id: number) => {
        const response = await apiClient.delete(`/courses/${id}`);
        return response.data; // Or just status for 204 No Content
    },
};```
2. Using the API Service in a React Component (or Hook/State Management)

A React component can then use this service to fetch data or perform actions. State management libraries like Redux Toolkit (with RTK Query), Zustand, or React Query are often used to manage API state, caching, and optimistic updates.
```
// Example: src/public/management/super_admin/views/courses/CourseListPage.tsx
import React, { useEffect, useState } from 'react';
import { courseApiService } from '../../services/courseApi'; // Adjust path as needed

interface Course { // Define a frontend type for Course
    id: number;
    title: string;
    description: string | null;
    start_date: string; // Dates might be strings from API
    end_date: string;
    is_published: boolean;
}

interface ApiResponse<T> { // Match your backend's successResponse structure
    success: boolean;
    data: T;
    message: string;
    pagination?: { total: number; page: number; limit: number; totalPages: number };
}

const CourseListPage: React.FC = () => {
    const [courses, setCourses] = useState<Course[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [pagination, setPagination] = useState<any>(null); // For pagination info
    const [currentPage, setCurrentPage] = useState<number>(1);

    useEffect(() => {
        const fetchCourses = async () => {
            setLoading(true);
            setError(null);
            try {
                const response: ApiResponse<Course[]> = await courseApiService.getCourses({ page: currentPage, limit: 10 });
                if (response.success) {
                    setCourses(response.data);
                    setPagination(response.pagination);
                } else {
                    setError(response.message || 'Failed to fetch courses');
                }
            } catch (err: any) {
                setError(err.response?.data?.message || err.message || 'An error occurred');
            } finally {
                setLoading(false);
            }
        };

        fetchCourses();
    }, [currentPage]);

    const handleCreateCourse = async () => {
        try {
            const newCourseData = { title: 'New Awesome Course', description: 'Learn cool things', start_date: '2024-01-01', end_date: '2024-02-01' };
            const response: ApiResponse<Course> = await courseApiService.createCourse(newCourseData);
            if (response.success && response.data) {
                setCourses(prev => [response.data!, ...prev]); // Add to list optimistically or refetch
                alert('Course created: ' + response.data.title);
            } else {
                alert('Failed to create course: ' + response.message);
            }
        } catch (err: any) {
            alert('Error creating course: ' + (err.response?.data?.message || err.message));
        }
    };
    
    // handleDelete, handleUpdate would follow similar patterns

    if (loading) return <p>Loading courses...</p>;
    if (error) return <p style={{ color: 'red' }}>Error: {error}</p>;

    return (
        <div>
            <h1>Course List</h1>
            <button onClick={handleCreateCourse}>Create New Course (Example)</button>
            <ul>
                {courses.map(course => (
                    <li key={course.id}>
                        {course.title} (Published: {course.is_published ? 'Yes' : 'No'})
                        {/* Add buttons for edit/delete */}
                    </li>
                ))}
            </ul>
            {/* Add Pagination controls here using `pagination` state */}
            {pagination && (
                <div>
                    Page {pagination.page} of {pagination.totalPages} (Total: {pagination.total})
                    <button onClick={() => setCurrentPage(p => Math.max(1, p - 1))} disabled={currentPage === 1}>Prev</button>
                    <button onClick={() => setCurrentPage(p => Math.min(pagination.totalPages, p + 1))} disabled={currentPage === pagination.totalPages}>Next</button>
                </div>
            )}
        </div>
    );
}; ```

export default CourseListPage;
3. Handling API State and User Feedback

Loading State: Show loading indicators (spinners, skeletons) while API requests are in progress.
Error State: Display user-friendly error messages if API calls fail.
Success Feedback: Notify the user of successful operations (e.g., "Course created successfully!") using toasts, modals, or inline messages.
Data Updates: Update the local frontend state (component state, Redux store, etc.) with the data received from the API to reflect changes in the UI. For POST, PUT, DELETE operations, you might refetch the list or update the local data optimistically/directly.
This provides a basic overview. In a real application, you'd likely use more sophisticated state management (like RTK Query for automatic caching, refetching, and mutation handling) and UI component libraries. The key is to have a clear separation for API calls and to manage the request lifecycle (loading, success, error) effectively in your React components.

---

Part 4 of Documentation: Frontend Overview, Development Workflow, and Conclusion

## 4. Frontend Overview (`public/`)

The `public/` directory serves all client-facing content, including static assets, server-rendered views, and the source code for more complex client-side applications like admin panels.

### 4.1. Static Assets
*   This includes images (e.g., `.png`, `.jpg`, `.svg`, `.ico`), global stylesheets (`.css`), client-side JavaScript files, fonts, and any other files that need to be served directly to the browser without server-side processing.
*   Fastify (via `@fastify/static` plugin, configured in `FastifyApp`) serves files from the `public/` directory, typically mapping the root of `public/` to the web server's root path (`/`).

### 4.2. Server-Side Views (`public/views/`)
*   **EJS Templates:** The boilerplate uses EJS (Embedded JavaScript templates) for server-side rendering of some HTML pages. These are typically simpler pages or initial shells for dashboards.
    *   Files have a `.ejs` extension (e.g., `public/views/auth/login.ejs`, `public/views/dashboard/admin.ejs`).
    *   EJS allows embedding JavaScript within HTML to dynamically generate content, iterate over data, and include partial templates.
*   **Usage with `@fastify/view`:**
    *   The `@fastify/view` plugin is configured in `FastifyApp` to use EJS as the templating engine and to look for templates in the `public/views/` directory.
    *   In route handlers (controllers), `reply.view('path/to/template.ejs', dataObject)` is used to render an EJS template and send the resulting HTML to the client. The `dataObject` makes data available within the template.

### 4.3. Client-Side Admin Panels (`public/management/`)
For more complex and interactive user interfaces, such as administrative dashboards, the boilerplate uses React.
*   **React (with TypeScript/TSX):**
    *   The source code for these React applications resides in subdirectories within `public/management/` (e.g., `public/management/super_admin/`, `public/management/admin/`).
    *   Components are typically written using TSX (TypeScript XML).
*   **Vite for Development and Build:**
    *   Vite is used as the build tool and development server for these React applications.
    *   Configuration files like `vite-config-admin.js` and `vite-config-super-admin.js` define how Vite processes and bundles the React code.
    *   **Development:** `npm run admin` or `npm run super_admin` (as defined in `package.json`) usually start Vite's dev server, providing features like Hot Module Replacement (HMR) for a fast development experience. These scripts often include `--watch` and `--sourcemap`.
    *   **Build:** The same commands also build the React applications into optimized static assets (HTML, JavaScript bundles, CSS files) that are then served by the Fastify backend (typically from a `dist` folder within each panel's directory, though this depends on Vite's configuration).
*   **Typical Structure (within each panel's directory, e.g., `public/management/super_admin/`):**
    *   `index.html`: The entry HTML file for the Single Page Application (SPA).
    *   `index.tsx` (or `main.tsx`): The main entry point for the React application, where the root component is rendered into the DOM.
    *   `components/` or `views/`: Directories for React components.
    *   `routes/`: Client-side routing configuration (e.g., using `react-router-dom`).
    *   `store/`: State management setup (e.g., Redux with `@reduxjs/toolkit`, Zustand, or React Context API).
    *   `assets/`: Panel-specific static assets.
    *   `helpers/`, `hooks/`, `services/` (for API calls): Utility functions, custom React hooks, and API interaction logic.

---

## 5. Development Workflow

The boilerplate is set up to support an efficient and modern development workflow.

### 5.1. Linting & Formatting
*   **ESLint (`.eslintrc.json`):** Used to analyze TypeScript/JavaScript code for potential errors, bugs, stylistic issues, and adherence to coding standards. Configuration is in `.eslintrc.json`.
    *   Scripts like `npm run server:lint` and `npm run client:lint` (from `package.json`) are typically used to run the linter, often with `--fix` to automatically correct issues.
*   **Prettier (`.prettierrc`):** An opinionated code formatter that ensures consistent code style across the project. Configuration is in `.prettierrc`.
    *   Often integrated with ESLint (`eslint-plugin-prettier`, `eslint-config-prettier`) and run via ESLint scripts or as a pre-commit hook.

### 5.2. Testing (`jest.config.js`)
*   **Jest:** The primary testing framework used for both backend and potentially frontend tests. Configuration is in `jest.config.js`. `ts-jest` is used to enable Jest to work with TypeScript code.
*   **Backend Tests:**
    *   **Unit Tests:** Located in `src/modules/*/test/`, these focus on testing individual functions or classes (e.g., service methods, helper functions) in isolation.
    *   **Integration Tests / API Tests:** Located in `src/modules/*/api_test/`, these test the interaction between different parts of the application, often by making actual HTTP requests to the API endpoints and verifying the responses, database state changes, etc. Tools like `supertest` might be used with Jest for this.
*   **Running Tests:**
    ```bash
    npm test # (Or a more specific script from package.json)
    ```
    Jest provides options for running tests in watch mode, generating coverage reports, etc.

### 5.3. Debugging
*   **Node.js Debugger:** Use the built-in Node.js inspector with a debugger client (like Chrome DevTools or VS Code debugger). Launch the server with the `--inspect` or `--inspect-brk` flag.
    ```bash
    node --inspect src/index.ts # (Or via nodemon configuration)
    ```
*   **Logging:** Effective logging (using Pino, Fastify's default, and custom loggers) is crucial. `pino-pretty` makes development logs more readable.
*   **TypeScript Type Safety:** TypeScript itself helps catch many potential errors during development before runtime.
*   **Browser Developer Tools:** For debugging frontend React applications.
*   **React Developer Tools:** Browser extension for inspecting React component hierarchies, props, and state.

---

## 6. Conclusion

### 6.1. Summary of Boilerplate Strengths
This boilerplate for the "Probaha Coaching Center Management System" provides a strong and comprehensive starting point by:
*   **Establishing a Modern Tech Stack:** Utilizing Node.js, Fastify, TypeScript, Sequelize, MySQL for the backend, and React with Vite for the frontend admin panels.
*   **Promoting a Modular Architecture:** The backend's organization into feature-specific modules (`src/modules/`) enhances maintainability, scalability, and team collaboration.
*   **Implementing Clear Design Patterns:** Following a structure similar to MVC with distinct layers for request handling (controllers), business logic (services), and data access (models).
*   **Automating Key Processes:** Leveraging autoloading for routes and models, and providing scripts for common development tasks (running, building, testing, linting).
*   **Prioritizing Code Quality:** Integrating TypeScript for static typing, ESLint for linting, and Prettier for code formatting.
*   **Including Robust Error Handling:** A multi-layered strategy ensures errors are caught, logged, and handled gracefully.
*   **Streamlining Database Management:** Using Sequelize ORM for database interactions and `sequelize-cli` for schema migrations.
*   **Supporting Efficient Frontend Development:** Using Vite for fast React development and optimized builds.

### 6.2. Next Steps for Development
With this boilerplate as a foundation, development can proceed by:
1.  **Defining Specific Features:** Flesh out the requirements for each module of the coaching center management system.
2.  **Developing Modules:** Implement each feature by creating or expanding modules within `src/modules/`, following the established patterns for models, services, controllers, and routes.
3.  **Building Frontend Interfaces:** Develop the React components and user interfaces for the admin panels and any other client-facing parts of the application.
4.  **Writing Comprehensive Tests:** Ensure high code coverage with unit and integration tests for both backend and frontend components.
5.  **Iterative Refinement:** Continuously review and refactor code to maintain quality and adapt to evolving requirements.
6.  **Security Considerations:** Implement authentication, authorization, input sanitization, and other security best practices throughout the application.
7.  **Deployment Planning:** Set up CI/CD pipelines and plan for deployment to staging and production environments, potentially using Docker.

This boilerplate aims to significantly reduce initial setup time and provide a clear path for building a complex and reliable application.

---

